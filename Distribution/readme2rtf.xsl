<?xml version="1.0" encoding="ISO-8859-1"?><xsl:stylesheet	version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"><!-- Need to instruct the XSLT processor to use text output rules for RTF.     See http://www.w3.org/TR/xslt#output for more details--><xsl:output method="text"/><!-- This first template matches our root element in the input file.     This will trigger the generation of some RTF code at the very beginning     of the output document and of a closing } brace at the very end.     In between we let the processor recursively process any contained     elements, which is what the apply-templates instruction does.-->     <xsl:template match='readme'><xsl:text>{\rtf1\mac\ansicpg10000\cocoartf100{\fonttbl\f0\fnil\fcharset77 LucidaGrande-Bold;\f1\fnil\fcharset77 LucidaGrande;}{\colortbl;\red255\green255\blue255;\red8\green61\blue161;}\margl1440\margr1440\vieww13260\viewh10420\viewkind0\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural</xsl:text><xsl:apply-templates/><xsl:text>}</xsl:text></xsl:template><!-- Match the readme title. Output some RTF code to make it bold --><xsl:template match="title">\f0\b\fs28 \cf0 <xsl:apply-templates/>\</xsl:template><!-- Match the author title. Output some RTF code to make it bold.     The author element might contain other markup, like the email address.     Again, this will be resolved recursively using apply-templates.--><xsl:template match="author">\f1\b0\fs24 \\\f0\b <xsl:apply-templates/>\</xsl:template><!-- Match description. Contains nested para elements --><xsl:template match="description">\\f0\b \ Description\\f1\b0 <xsl:apply-templates/></xsl:template><!-- paragraphs inside descriptions --><xsl:template match="para"><xsl:apply-templates/>\\</xsl:template><!-- Make URLs blue. Can't do anything better in RTF --><xsl:template match="url">\cf2 <xsl:apply-templates/>\cf0 </xsl:template><!-- Make email blue and add angle brackets (lt and gt) --><xsl:template match="email">\cf2 &lt;<xsl:apply-templates/>&gt;\cf0 </xsl:template><!-- Output Requirements title --><xsl:template match="requirements">\f0\b \ Requirements\\f1\b0 <xsl:apply-templates/>\\</xsl:template><!-- Output version history. First output the bold title --><xsl:template match="history">\f0\b History\f1\b0 \<xsl:apply-templates/></xsl:template><!-- Inside history, we will find entry elements.     For these, we will put the date and version on one line     in this template using value-of instructions. Then we'll     recursively let it process all item elements--><xsl:template match="entry"><xsl:value-of select="date"/> Version <xsl:value-of select="version"/>\<xsl:apply-templates select="item"/>\</xsl:template><!-- One item element, multiple are possible in an entry.     Output a dash and space, then the item text--><xsl:template match="item">- <xsl:apply-templates/>\</xsl:template></xsl:stylesheet>