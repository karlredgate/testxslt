<?xml version="1.0" encoding="ISO-8859-1"?><!-- $Id$ --><xsl:stylesheet	version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"><!-- Need to instruct the XSLT processor to use HTML output rules.     See http://www.w3.org/TR/xslt#output for more details--><xsl:output method="html" encoding="ISO-8859-1"/><xsl:param name="version"/><!-- This first template matches our root element in the input file.     This will trigger the generation of the HTML skeleton document.     In between we let the processor recursively process any contained     elements, which is what the apply-templates instruction does.     We also pick some stuff out explicitly in the head section using     value-of instructions.-->     <xsl:template match='readme'><html>	<head>		<title><xsl:value-of select="title"/> v<xsl:value-of select="$version"/></title>		<META name="Author" content="{author/text()}"/>	</head>		<body>		<xsl:apply-templates/>				<p>&#160;</p>		<p>&#160;</p>	</body></html></xsl:template><!-- Match the readme title. Output as H1 --><xsl:template match="title"><h1><xsl:apply-templates/> v<xsl:value-of select="$version"/></h1></xsl:template><!-- Match the author title. Output some code to make it bold.     The author element might contain other markup, like the email address.     Again, this will be resolved recursively using apply-templates.--><xsl:template match="author"><p><b><i><xsl:apply-templates/></i></b></p></xsl:template><!-- Make email an anchor and add angle brackets (lt and gt) --><xsl:template match="email">&lt;<a href="mailto:{.}"><xsl:apply-templates/></a>&gt;</xsl:template><!-- Match description. Contains nested para elements --><xsl:template match="description"><p>&#160;</p><h2>Description</h2><xsl:apply-templates/></xsl:template><!-- paragraphs inside descriptions --><xsl:template match="para"><p><xsl:apply-templates/></p></xsl:template><!-- Make URLs into anchors --><xsl:template match="url"><a href="{.}"><xsl:apply-templates/></a></xsl:template><!-- Output Requirements title --><xsl:template match="requirements"><p>&#160;</p><h2>Requirements</h2><p><xsl:apply-templates/></p></xsl:template><!-- Output version history. Make it a table. Here we have     to create the table itself plus the header row. The     rest will be handled recursively by the template that     matches the entries.--><xsl:template match="history"><p>&#160;</p><h2>History</h2><table border="0" cellspacing="1" cellpadding="1"><tr><th bgcolor="#cccccc">Date</th><th bgcolor="#cccccc">Version</th><th bgcolor="#cccccc">Changes</th></tr><xsl:apply-templates/></table></xsl:template><!-- Inside history, we will find entry elements.     For every one of these, we will output a table row.     the only special case is the changes column which might     contain multiple item values. These are handled in their     own template. We'll output them as an unordered list (ul).     The ul itself goes into this template, but the individual li     items are created in their own template.--><xsl:template match="entry"><tr><td bgcolor="#eeeeee" valign="top" align="right"><nobr><xsl:value-of select="date"/></nobr></td><td bgcolor="#eeeeee" valign="top" align="center"><xsl:value-of select="version"/></td><td bgcolor="#eeeeee" valign="top"><ul>	<xsl:apply-templates select="item"/></ul></td></tr></xsl:template><!-- One item element, multiple are possible in an entry.     Output a <li> tag, then the item text--><xsl:template match="item"><li><xsl:apply-templates/></li></xsl:template></xsl:stylesheet>