/* Automatically generated by Ragel from "ragel_xmldeclscanner.c".
 *
 * Parts of this file are copied from Ragel source covered by the GNU
 * GPL. As a special exception, you may use the parts of this file copied
 * from Ragel source without restriction. The remainder is derived from
 * "ragel_xmldeclscanner.c" and inherits the copyright status of that file.
 */

# 1 "ragel_xmldeclscanner.c"

/*
 * This is an input file for the "Ragel" finite state machine compiler utility.
 * It produces output code which implements a tag scanner for XML data.
 * It is used for intelligent xml tag completion in an XML editor interface.
 * 
 * See the Ragel online documentation for additional
 * information about the format of this file.
 *
 * Written by Marc Liyanage <http://www.entropy.ch>
 *
 */
 
 
#include <CoreFoundation/CoreFoundation.h>
#include "ragel_xmldeclscanner.h"


# 29 "ragel_xmldeclscanner_out.c"
/* Forward dec state for the transition structure. */
struct XMLDeclScannerStateStruct;

/* Only non-static data: current state, acceptance indicator. */
struct XMLDeclScannerStruct
{
	int *curState;
	int accept;
# 20 "ragel_xmldeclscanner.c"

		char *mark_encodingstart;
		char *mark_encodingend;
	
# 43 "ragel_xmldeclscanner_out.c"
};
typedef struct XMLDeclScannerStruct XMLDeclScanner;

/* Init the fsm. */
void XMLDeclScannerInit( XMLDeclScanner *fsm );

/* Execute some chunk of data. */
void XMLDeclScannerExecute( XMLDeclScanner *fsm, char *data, int dlen );

/* Indicate to the fsm tha there is no more data. */
void XMLDeclScannerFinish( XMLDeclScanner *fsm );

/* Did the machine accept? */
int XMLDeclScannerAccept( XMLDeclScanner *fsm );

# 25 "ragel_xmldeclscanner.c"


# 62 "ragel_xmldeclscanner_out.c"
#define f XMLDeclScanner_f
#define s XMLDeclScanner_s
#define k XMLDeclScanner_k
#define i XMLDeclScanner_i
#define t XMLDeclScanner_t

#define SPEC_ANY_FLAT    0x01
#define SPEC_ANY_SINGLE  0x02
#define SPEC_ANY_RANGE   0x04
#define SPEC_ANY_DEF     0x08
#define SPEC_IS_FINAL    0x10
#define SPEC_OUT_FUNC    0x20

/* The array of functions. */
static int XMLDeclScanner_f[] = {
	1, 0, 1, 1
};

/* The array of keys of transitions. */
static char XMLDeclScanner_k[] = {
	-69, -65, 60, -17, 60, 63, 120, 109, 
	108, 32, 9, 13, 118, 101, 114, 115, 
	105, 111, 110, 61, 34, 39, 45, 46, 
	58, 95, 48, 57, 65, 90, 97, 122, 
	39, 45, 46, 58, 95, 48, 57, 65, 
	90, 97, 122, 39, 45, 46, 58, 95, 
	48, 57, 65, 90, 97, 122, 39, 45, 
	46, 58, 95, 48, 57, 65, 90, 97, 
	122, 39, 45, 46, 58, 95, 48, 57, 
	65, 90, 97, 122, 32, 9, 13, 45, 
	46, 58, 95, 48, 57, 65, 90, 97, 
	122, 34, 45, 46, 58, 95, 48, 57, 
	65, 90, 97, 122, 34, 45, 46, 58, 
	95, 48, 57, 65, 90, 97, 122, 34, 
	45, 46, 58, 95, 48, 57, 65, 90, 
	97, 122, 34, 45, 46, 58, 95, 48, 
	57, 65, 90, 97, 122, 32, 9, 13, 
	101, 110, 99, 111, 100, 105, 110, 103, 
	61, 34, 39, 65, 90, 97, 122, 34, 
	45, 46, 95, 48, 57, 65, 90, 97, 
	122, 34, 45, 46, 95, 48, 57, 65, 
	90, 97, 122, 34, 45, 46, 95, 48, 
	57, 65, 90, 97, 122, 32, 63, 9, 
	13, 65, 90, 97, 122, 39, 45, 46, 
	95, 48, 57, 65, 90, 97, 122, 39, 
	45, 46, 95, 48, 57, 65, 90, 97, 
	122, 39, 45, 46, 95, 48, 57, 65, 
	90, 97, 122, 32, 63, 9, 13, 116, 
	97, 110, 100, 97, 108, 111, 110, 101, 
	61, 34, 39, 110, 121, 101, 115, 39, 
	111, 39, 32, 63, 9, 13, 110, 121, 
	101, 115, 34, 111, 34, 32, 63, 9, 
	13, 63, 63, 115, 62, 0
};

/* The array of indicies into the transition array. */
static unsigned char XMLDeclScanner_i[] = {
	1, 2, 3, 4, 3, 5, 6, 7, 
	8, 9, 9, 10, 11, 12, 13, 14, 
	15, 16, 17, 18, 19, 20, 21, 21, 
	21, 21, 21, 21, 22, 23, 24, 24, 
	24, 24, 24, 24, 22, 23, 24, 24, 
	24, 24, 24, 24, 22, 23, 24, 24, 
	24, 24, 24, 24, 22, 23, 24, 24, 
	24, 24, 24, 24, 25, 25, 26, 27, 
	27, 27, 27, 27, 27, 28, 29, 30, 
	30, 30, 30, 30, 30, 28, 29, 30, 
	30, 30, 30, 30, 30, 28, 29, 30, 
	30, 30, 30, 30, 30, 28, 29, 30, 
	30, 30, 30, 30, 30, 25, 25, 31, 
	32, 33, 34, 35, 36, 37, 38, 39, 
	40, 41, 42, 42, 43, 44, 45, 45, 
	45, 45, 45, 43, 44, 45, 45, 45, 
	45, 45, 43, 44, 45, 45, 45, 45, 
	45, 46, 47, 46, 48, 48, 49, 50, 
	51, 51, 51, 51, 51, 49, 50, 51, 
	51, 51, 51, 51, 49, 50, 51, 51, 
	51, 51, 51, 46, 47, 46, 52, 53, 
	54, 55, 56, 57, 58, 59, 60, 61, 
	62, 63, 64, 65, 66, 67, 68, 69, 
	68, 70, 47, 70, 71, 72, 73, 74, 
	75, 76, 75, 70, 47, 70, 47, 47, 
	77, 78, 79, 79, 0
};

/* The aray of states. */
static int XMLDeclScanner_s[] = {
	768, 0, 0, 1026, 0, 0, 1, 1026, 
	1, 1, 1, 1026, 2, 2, 1, 1026, 
	3, 3, 2, 1026, 5, 5, 1, 1026, 
	6, 6, 1, 1026, 7, 7, 1, 1026, 
	8, 8, 1, 1286, 9, 9, 1, 1, 
	1026, 12, 11, 1, 1026, 13, 12, 1, 
	1026, 14, 13, 1, 1026, 15, 14, 1, 
	1026, 16, 15, 1, 1026, 17, 16, 1, 
	1026, 18, 17, 1, 1026, 19, 18, 1, 
	1026, 20, 19, 2, 1286, 22, 21, 4, 
	3, 1286, 32, 28, 5, 3, 1286, 43, 
	36, 5, 3, 1286, 54, 44, 5, 3, 
	1286, 65, 52, 5, 3, 1286, 76, 60, 
	1, 1, 1286, 79, 62, 4, 3, 1286, 
	89, 69, 5, 3, 1286, 100, 77, 5, 
	3, 1286, 111, 85, 5, 3, 1286, 122, 
	93, 5, 3, 1286, 133, 101, 1, 1, 
	1026, 136, 103, 1, 1026, 137, 104, 1, 
	1026, 138, 105, 1, 1026, 139, 106, 1, 
	1026, 140, 107, 1, 1026, 141, 108, 1, 
	1026, 142, 109, 1, 1026, 143, 110, 1, 
	1026, 144, 111, 1, 1026, 145, 112, 2, 
	1028, 147, 114, 2, 1286, 151, 116, 4, 
	3, 1286, 161, 123, 4, 3, 1286, 171, 
	130, 4, 3, 1286, 181, 137, 2, 1, 
	1028, 185, 140, 2, 1286, 189, 142, 4, 
	3, 1286, 199, 149, 4, 3, 1286, 209, 
	156, 4, 3, 1286, 219, 163, 2, 1, 
	1026, 223, 166, 1, 1026, 224, 167, 1, 
	1026, 225, 168, 1, 1026, 226, 169, 1, 
	1026, 227, 170, 1, 1026, 228, 171, 1, 
	1026, 229, 172, 1, 1026, 230, 173, 1, 
	1026, 231, 174, 1, 1026, 232, 175, 1, 
	1026, 233, 176, 2, 1026, 235, 178, 2, 
	1026, 237, 180, 1, 1026, 238, 181, 1, 
	1026, 239, 182, 1, 1026, 240, 183, 1, 
	1026, 241, 184, 1, 1286, 242, 185, 2, 
	1, 1026, 246, 188, 2, 1026, 248, 190, 
	1, 1026, 249, 191, 1, 1026, 250, 192, 
	1, 1026, 251, 193, 1, 1026, 252, 194, 
	1, 1286, 253, 195, 2, 1, 1026, 257, 
	198, 1, 1026, 258, 199, 2, 1026, 260, 
	201, 1, 792, 261, 202, 792, 261, 203, 
	0
};

/* The array of transitions. */
static int *XMLDeclScanner_t[] = {
	0, 0, s+7, 0, s+11, 0, s+19, 0, 
	s+3, 0, s+23, 0, s+27, 0, s+31, 0, 
	s+35, 0, s+40, 0, s+44, 0, s+48, 0, 
	s+52, 0, s+56, 0, s+60, 0, s+64, 0, 
	s+68, 0, s+72, 0, s+106, 0, s+76, 0, 
	s+86, 0, s+81, 0, s+101, 0, s+96, 0, 
	s+91, 0, s+136, 0, s+116, 0, s+111, 0, 
	s+131, 0, s+126, 0, s+121, 0, s+140, 0, 
	s+144, 0, s+148, 0, s+152, 0, s+156, 0, 
	s+160, 0, s+164, 0, s+168, 0, s+172, 0, 
	s+176, 0, s+200, 0, s+180, f+0, s+195, f+2, 
	s+190, 0, s+185, 0, s+330, 0, s+334, 0, 
	s+204, f+0, s+219, f+2, s+214, 0, s+209, 0, 
	s+228, 0, s+232, 0, s+236, 0, s+240, 0, 
	s+244, 0, s+248, 0, s+252, 0, s+256, 0, 
	s+260, 0, s+264, 0, s+297, 0, s+268, 0, 
	s+284, 0, s+272, 0, s+276, 0, s+280, 0, 
	s+292, 0, s+288, 0, s+326, 0, s+313, 0, 
	s+301, 0, s+305, 0, s+309, 0, s+321, 0, 
	s+317, 0, s+224, 0, s+338, 0, s+341, 0, 
	0
};

/* The start state. */
static int *XMLDeclScanner_start = s+15;

/* Init the fsm to a runnable state. */
void XMLDeclScannerInit( XMLDeclScanner *fsm )
{
	fsm->curState = XMLDeclScanner_start;
	fsm->accept = 0;
# 29 "ragel_xmldeclscanner.c"
{ 
		fsm->mark_encodingstart = fsm->mark_encodingend = NULL;
	 }
# 233 "ragel_xmldeclscanner_out.c"
}

/* Did the fsm accept? */
int XMLDeclScannerAccept( XMLDeclScanner *fsm )
{
	return fsm->accept;
}

/* Binary search an array of keys looking for a key. */
static char *XMLDeclScannerBSearch( char c, char *keys, int len )
{
	char *lower = keys;
	char *mid;
	char *upper = keys + len - 1;
	while (1) {
		if ( upper < lower )
			return 0;

		/* Find the midpoint. */
		mid = lower + ((upper-lower) >> 1);

		if ( c < *mid )
			upper = mid - 1;
		else if ( c > *mid )
			lower = mid + 1;
		else
			return mid;
	}
}

/* Binary search an array of keys looking for a key. */
static char *XMLDeclScannerRangeBSearch( char c, char *keys, int len )
{
	char *lower = keys;
	char *mid;
	char *upper = keys + len - 2;
	while (1) {
		if ( upper < lower )
			return 0;

		/* Find the midpoint. Be sure to settle on the
		 * lower end of a range. */
		mid = lower + (((upper-lower) >> 1) & ~1);

		if ( c < mid[0] )
			upper = mid - 2;
		else if ( c > mid[1] )
			lower = mid + 2;
		else {
			/* The key was found in the range mid, return it. */
			return mid;
		}
	}
}

/* Execute the fsm on some chunk of data. */
void XMLDeclScannerExecute( XMLDeclScanner *fsm, char *data, int dlen )
{
	char *p = data;
	int len = dlen;
	int *cs = fsm->curState;
	int specs, **trans, *funcs, nfuncs;
	char *keys;
	unsigned char *inds;

	if ( data == 0 )
		goto finishInput;

again:
	if ( cs == 0 || len == 0 )
		goto out;

	/* Get required data. */
	specs = *cs++;
	keys = k + *cs++;
	inds = i + *cs++;

	/* Try flat index. */
	if ( specs & SPEC_ANY_FLAT ) {
		int indsLen = *cs++;
		keys += 2;
		inds += indsLen;
	}

	/* Try binary search single. */
	if ( specs & SPEC_ANY_SINGLE ) {
		/* Try to find the key. */
		int indsLen = *cs++;
		char *match = XMLDeclScannerBSearch( *p, keys, indsLen );

		if ( match != 0 ) {
			trans = t + (inds[match - keys]<<1);
			goto match;
		}

		/* Advance over the keys and indicies. */
		keys += indsLen;
		inds += indsLen;
	}

	/* Try binary search range. */
	if ( specs & SPEC_ANY_RANGE ) {
		/* Try to find the key. */
		int indsLen = *cs++;
		char *match = XMLDeclScannerRangeBSearch( *p, keys, (indsLen<<1) );

		if ( match != 0 ) {
			trans = t + (inds[(match - keys)>>1]<<1);
			goto match;
		}

		/* Advance over the keys and indicies. */
		keys += (indsLen<<1);
		inds += indsLen;
	}

	/* Try the default transition. */
	if ( specs & SPEC_ANY_DEF ) {
		trans = t + ((*inds)<<1);
		goto match;
	}

	/* No match. */
	cs = 0;
	goto out;

match:
	/* Move to the new state. */
	cs = *trans++;

	/* Check for functions. */
	if ( (funcs=*trans) == 0 )
		goto noFuncs;

execFuncs:
	nfuncs = *funcs++;
	while ( nfuncs-- > 0 ) {
		switch ( *funcs++ ) {
	case 0:
# 34 "ragel_xmldeclscanner.c"
	{
		DEBUG && fprintf(stderr, "encodingstart: %d %c\n", p - data, *p);
		fsm->mark_encodingstart = p;
	} break;
	case 1:
# 39 "ragel_xmldeclscanner.c"
	{
		fsm->mark_encodingend = p;
		DEBUG && fprintf(stderr, "encodingend: %d %c\n", p - data, *p);
		DEBUG && fprintf(stderr, "length: %d\n", fsm->mark_encodingend - fsm->mark_encodingstart);
	} break;
# 385 "ragel_xmldeclscanner_out.c"
		}
	}

noFuncs:
	p++, len--;
	goto again;

finishInput:
	if ( cs != 0 && *cs & SPEC_IS_FINAL ) {
		/* The machine accepts. */
		fsm->accept = 1;
		/* If finishing in a final state then execute the
		 * out functions for it. (if any). */
		if ( *cs & SPEC_OUT_FUNC ) {
			funcs = f+*(cs + (*cs>>8)-1);
			len = 1;
			goto execFuncs;
		}
	}
	else {
		/* If we are not in a final state then this
		 * is an error. Move to the error state. */
		fsm->curState = 0;
	}

out:
	fsm->curState = cs;
}

/* Indicate to the fsm that the input is done. Does cleanup tasks. */
void XMLDeclScannerFinish( XMLDeclScanner *fsm )
{
	XMLDeclScannerExecute( fsm, 0, 0 );
}

#undef f
#undef s
#undef k
#undef i
#undef t
#undef SPEC_ANY_FLAT
#undef SPEC_ANY_SINGLE
#undef SPEC_ANY_RANGE
#undef SPEC_ANY_DEF
#undef SPEC_IS_FINAL
#undef SPEC_OUT_FUNC

# 66 "ragel_xmldeclscanner.c"





unsigned int getEncodingFromXmlDecl(char *data, int len) {

	int encodinglength, result;
	CFStringRef encodingString;
	
	XMLDeclScanner scanner, *machine = &scanner;

	XMLDeclScannerInit(machine);
	XMLDeclScannerExecute(machine, data, len > 512 ? 512 : len);
	XMLDeclScannerFinish(machine);

	if (!XMLDeclScannerAccept(machine)) {
		return 0;
	}

	encodinglength = machine->mark_encodingend - machine->mark_encodingstart;


	encodingString = CFStringCreateWithBytes (
		NULL,
		machine->mark_encodingstart,
		(CFIndex)encodinglength,
		kCFStringEncodingASCII,
		0
	);

	result = CFStringConvertIANACharSetNameToEncoding(encodingString);
	CFRelease(encodingString);

	if (result == kCFStringEncodingInvalidId)
		return 0;
		
	result = CFStringConvertEncodingToNSStringEncoding(result);
	
	if (result == kCFStringEncodingInvalidId)
		return 0;

	return result;
	
}



/*	No longer used, now using CoreFoundation 

	struct encodingPair {
		int encoding;
		char *matchstring;
	};

	struct encodingPair encodingPairs[] = {
		{NSUTF8StringEncoding, "UTF-8"},
		{NSISOLatin1StringEncoding, "ISO-8859-1"},
		{0, NULL},
	};



	for (i = 0; encodingPairs[i].matchstring; i++) {

		testlength = strlen(encodingPairs[i].matchstring);
		if (!strncasecmp(machine->mark_encodingstart, encodingPairs[i].matchstring, encodinglength < testlength ? encodinglength : testlength)) {
			return encodingPairs[i].encoding;
		}
		
	}

	return 0;

*/
	
